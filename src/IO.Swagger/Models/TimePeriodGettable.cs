/*
 * Knetik Platform API Documentation latest 
 *
 * This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com.
 *
 * OpenAPI spec version: latest 
 * Contact: support@knetik.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;

namespace IO.Swagger.Models
{

    /// <summary>
    /// 
    /// </summary>
    [DataContract]
    public partial class TimePeriodGettable : Behavior,  IEquatable<TimePeriodGettable>
    {

        /// <summary>
        /// Initializes a new instance of the <see cref="TimePeriodGettable" /> class.
        /// </summary>
        /// <param name="Description">Description.</param>
        /// <param name="TypeHint">Used for polymorphic type recognition and thus must match an expected type with additional properties.</param>
        /// <param name="GetLimit">The time period limit (required).</param>
        /// <param name="GroupName">The name of a group of items. Multiple items with the same group name will be limited together, leave null to be assigned a random unique name. It is typical that the other properties here will be the same for all, but this is not enforced and the item being recieved will use its settings..</param>
        /// <param name="TimeLength">The length of time (required).</param>
        /// <param name="UnitOfTime">The unit of time (required).</param>
        public TimePeriodGettable(string Description = default(string), string TypeHint = default(string), int? GetLimit = default(int?), string GroupName = default(string), int? TimeLength = default(int?), string UnitOfTime = default(string))
        {
            // to ensure "GetLimit" is required (not null)
            if (GetLimit == null)
            {
                throw new InvalidDataException("GetLimit is a required property for TimePeriodGettable and cannot be null");
            }
            else
            {
                this.GetLimit = GetLimit;
            }
            // to ensure "TimeLength" is required (not null)
            if (TimeLength == null)
            {
                throw new InvalidDataException("TimeLength is a required property for TimePeriodGettable and cannot be null");
            }
            else
            {
                this.TimeLength = TimeLength;
            }
            // to ensure "UnitOfTime" is required (not null)
            if (UnitOfTime == null)
            {
                throw new InvalidDataException("UnitOfTime is a required property for TimePeriodGettable and cannot be null");
            }
            else
            {
                this.UnitOfTime = UnitOfTime;
            }
            this.Description = Description;
            this.TypeHint = TypeHint;
            this.GroupName = GroupName;
            
        }

        /// <summary>
        /// Gets or Sets Description
        /// </summary>
        [DataMember(Name="description")]
        public string Description { get; set; }
        /// <summary>
        /// Used for polymorphic type recognition and thus must match an expected type with additional properties
        /// </summary>
        /// <value>Used for polymorphic type recognition and thus must match an expected type with additional properties</value>
        [DataMember(Name="type_hint")]
        public string TypeHint { get; set; }
        /// <summary>
        /// The time period limit
        /// </summary>
        /// <value>The time period limit</value>
        [DataMember(Name="get_limit")]
        public int? GetLimit { get; set; }
        /// <summary>
        /// The name of a group of items. Multiple items with the same group name will be limited together, leave null to be assigned a random unique name. It is typical that the other properties here will be the same for all, but this is not enforced and the item being recieved will use its settings.
        /// </summary>
        /// <value>The name of a group of items. Multiple items with the same group name will be limited together, leave null to be assigned a random unique name. It is typical that the other properties here will be the same for all, but this is not enforced and the item being recieved will use its settings.</value>
        [DataMember(Name="group_name")]
        public string GroupName { get; set; }
        /// <summary>
        /// The length of time
        /// </summary>
        /// <value>The length of time</value>
        [DataMember(Name="time_length")]
        public int? TimeLength { get; set; }
        /// <summary>
        /// The unit of time
        /// </summary>
        /// <value>The unit of time</value>
        [DataMember(Name="unit_of_time")]
        public string UnitOfTime { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class TimePeriodGettable {\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  TypeHint: ").Append(TypeHint).Append("\n");
            sb.Append("  GetLimit: ").Append(GetLimit).Append("\n");
            sb.Append("  GroupName: ").Append(GroupName).Append("\n");
            sb.Append("  TimeLength: ").Append(TimeLength).Append("\n");
            sb.Append("  UnitOfTime: ").Append(UnitOfTime).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public  new string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            if (obj.GetType() != GetType()) return false;
            return Equals((TimePeriodGettable)obj);
        }

        /// <summary>
        /// Returns true if TimePeriodGettable instances are equal
        /// </summary>
        /// <param name="other">Instance of TimePeriodGettable to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(TimePeriodGettable other)
        {

            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    this.Description == other.Description ||
                    this.Description != null &&
                    this.Description.Equals(other.Description)
                ) && 
                (
                    this.TypeHint == other.TypeHint ||
                    this.TypeHint != null &&
                    this.TypeHint.Equals(other.TypeHint)
                ) && 
                (
                    this.GetLimit == other.GetLimit ||
                    this.GetLimit != null &&
                    this.GetLimit.Equals(other.GetLimit)
                ) && 
                (
                    this.GroupName == other.GroupName ||
                    this.GroupName != null &&
                    this.GroupName.Equals(other.GroupName)
                ) && 
                (
                    this.TimeLength == other.TimeLength ||
                    this.TimeLength != null &&
                    this.TimeLength.Equals(other.TimeLength)
                ) && 
                (
                    this.UnitOfTime == other.UnitOfTime ||
                    this.UnitOfTime != null &&
                    this.UnitOfTime.Equals(other.UnitOfTime)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            // credit: http://stackoverflow.com/a/263416/677735
            unchecked // Overflow is fine, just wrap
            {
                int hash = 41;
                // Suitable nullity checks etc, of course :)
                    if (this.Description != null)
                    hash = hash * 59 + this.Description.GetHashCode();
                    if (this.TypeHint != null)
                    hash = hash * 59 + this.TypeHint.GetHashCode();
                    if (this.GetLimit != null)
                    hash = hash * 59 + this.GetLimit.GetHashCode();
                    if (this.GroupName != null)
                    hash = hash * 59 + this.GroupName.GetHashCode();
                    if (this.TimeLength != null)
                    hash = hash * 59 + this.TimeLength.GetHashCode();
                    if (this.UnitOfTime != null)
                    hash = hash * 59 + this.UnitOfTime.GetHashCode();
                return hash;
            }
        }

        #region Operators

        public static bool operator ==(TimePeriodGettable left, TimePeriodGettable right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(TimePeriodGettable left, TimePeriodGettable right)
        {
            return !Equals(left, right);
        }

        #endregion Operators

    }
}
